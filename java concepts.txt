Object Oriented Programming Language
---------------------------------------------------------
1)Class :- A class is known as object framework or blue print of an object.
A class contains variables and methods.
2)Object is a reference pointer to the class.
we can access the variables and methods of a class using object.
-------------------------------------------------------------------------------------
3)Inheritance (is-a)relationship
(parent class/base class/super class)------<--------------(child class,sub class,derived class)
It is a mechanism in which one object acquires all the properties and behaviour of a parent class.
It has parent class relationship which is known as is-a relationship.
It is a tight coupling.The child class depend upon the parent class.It is reusability of a parent class.
we use the key word super to access the super class methods and variables.
we use the keyword extends to access the parent class into the child class.
example:- we have iphone 6,7,8,9,10...14
all features of iphone 6 is present in iphone 7 plus we have some added features.we are not writing the code from the begining.
we are reusing the exsisting 6 features.

The child class depend upon the parent class.
If the parent class fails to start or have any error than the child class will also fail to start.because child class is totally dependend on the parent class.




----------------------------------------------------------------------------------------------------------
4)Aggregation(has-a)relationship
-----------------------------------------------------------
It is a has-a relationship.
example :- 
employee has a address
employee has a salary
house has a kitchen
Here also we have code reusability.here it is loosely coupled.
In this we will call a class with in another class.
Spring it support has-a relationship.
code reuse is best achieved by aggrgation then the inheritance(is-a) relationship.
----------------------------------------------------------------------------------------------------------------------------------------------
advantage of Aggregation
-----------------------------------------
1)Code Reusability:- we can use the existing classes as part of main class .This promote reuse in object-oriented programming.
2)Modularity:- Aggrigation promotes a modular design,allow us to break down complex system into smaller ,manageable parts.
.each part can be developed and tested independently.
3)encapsulation:- aggregation allows you to encapsulate the dehaviour and data of the part class within the whole class.This means that the part class are hidden from the outside world,which enhances data security and maintainabillty.
4)Improve Testing  facility.
5)reduce complexity.
6)scalability :- aggregation allows us to add or remove parts as needed.
7)Better Collaboration:- Developers can work on different parts of the system independently.
8)Has-A relationship is also called aggregation and composition.
9)is-a relationship is a specialization and generalization relationship.
10)assosiation is a aggregation that represents a "whole-part" relationship between classes.
---------------------------------------------------------------------------------------------------------------
example:-

create a connection class
we call it inside our main class.

@Autowire
JDBCConnection jdbc;

--->username/password is incorrect.
Then also the main class will execute other statements.

---------------------------------------------------------------------------------------------------------------------------------------------
example-1
--------------------
package org.sandip;

public class Address
{
	int streettno;
String city,state,loc;
public Address(int streettno, String city, String state, String loc) {
	super();
	this.streettno = streettno;
	this.city = city;
	this.state = state;
	this.loc = loc;
}
@Override
public String toString() {
	return "Address [streettno=" + streettno + ", city=" + city + ", state=" + state + ", loc=" + loc + "]";
}


}
----------------------------------------------------------------------------------------
package org.sandip;

public class Employee
{
int empno;
String name,dept;
Address add;
public Employee(int empno, String name, String dept, Address add) {
	super();
	this.empno = empno;
	this.name = name;
	this.dept = dept;
	this.add = add;
}
@Override
public String toString() {
	return "Employee [empno=" + empno + ", name=" + name + ", dept=" + dept + ", add=" + add + "]";
}
public void display()
{
	System.out.println("the empno is "+empno);
	System.out.println("the name is "+name);
	System.out.println("the dept is "+dept);
	System.out.println("the address is "+add);
	
}

}
--------------------------------------------------------------------------------------------------------
package org.sandip;

public class Mainclass 
{
public static void main(String[] args)
{
Address ob=new Address(10,"Bangalore","Karnataka","near airport");
Employee ob1=new Employee(101,"sandip","sales",ob);
ob1.display();
}
}
------------------------------------------------------------------------------------------------------------------
wap to create a Bank class (accno,branch,balance,customer)
customer class (custid,name,address)
-------------------------------------------------------------------------------------------------
inheritance
----------------------
-----------------------------------
Exception Handling
-------------------------------
why we are going for exception handling
--------------------------------------------------------
There are three types of error
1)compile time error(missing of semi-colon,spelling mistake,...)
2)run time error(divide by zero error,data type mismatch,crossing the array limit,...)
3)logical error

we use exception handling for runtime error mostly .so that if the enduser enter wrong input the program should not terminate it should give proper error message and continue till the end of the program.   

There are three types of exception
1)Checked Exception :- sql exception,IOException,Interrupted exception .This we have to handle then only it will allow to execute the program. 
2)Unchecked Exception:-Arithmatic exception,Null pointer,arrayindex outof bound....
3)Error:- harddisk failure,memory stack overflow.
-----------------------
we have five keywords
1)try,2)catch,3)finally,4)throw 5)throws
-------------------------------------------------------------
throw is used for user defined exception.
example:- marks should be greater than zero.
salary show be greater than 18000.
---------------------------------------------------------
throws exception is mainly used for checked exception.It doesn't have any body.It is written with main method or any method.
------------------------------------------------------------------------------------------
example-1
-------------------
//checked exception unit you handle the error it will not allow to execute.
package org.sandip;
public class Test1 extends Thread
{
public static void main(String[] args) throws Exception 
{
	for(int i=1;i<=10;i++)
		{
			System.out.println(i);
			Thread.sleep(1000);
			}
	}	
}
----------------------------------------------------------------------------------
example-2
----------------------
//checked exception unit you handle the error it will not allow to execute.
package org.sandip;
public class Test1 extends Thread
{
public static void main(String[] args)  
{
	for(int i=1;i<=10;i++)
		{
			System.out.println(i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
			System.out.println("Interrupted Exception");
			}
			}
	}	
}
------------------------------------------------------------------
inheritance
----------------------
package org.sandip;
import java.util.*;
public class Student 
{
int rollno;
String name,address;
void input()
{
	Scanner ob=new Scanner(System.in);
	System.out.println("enter rollno,name,address");
	rollno=ob.nextInt();
	name=ob.next();
	address=ob.next();
}
void display()
{
	System.out.println("the rollno is"+rollno+"the name is "+name+"the address is "+address);
}
}
------------------------------------------------------------
package org.sandip;
import java.util.*;
public class Marks extends Student
{
int phy,chem,math,total,avg;
String grade;
void input()
{
	super.input();
	Scanner ob=new Scanner(System.in);
	System.out.println("enter phy,chem,math marks");
	phy=ob.nextInt();
	chem=ob.nextInt();
	math=ob.nextInt();
	total=phy+chem+math;
	avg=total/3;
	if(avg>70)
		grade="First Grade";
	else if(avg>60)
		grade="Second Grade";
	else if(avg>50)
		grade="Third Grade";
	else
		grade="Fail";
}
void display()
{
	super.display();
	System.out.println("the total is "+total);
	System.out.println("the average is "+avg);
	System.out.println("The grade is "+grade);
}
public static void main(String[] args)
{
	Marks ob=new Marks();  //child class
	ob.input();
	ob.display();
}
}
---------------------------------------------------------------------------------------
wap to create a customer class(name,address,phoneno)
create class called shopping extending the customer class
shopping class(product id,product name,price)

and display the details
------------------------------------------------------------------------
polymorphism:-
Method Overloading :- compile time Polymerphism.we need one class.
The method name is same but the return type and parameter has different data type.
example:-
int sum(int a,int b);
float sum(float a,float b);
--------------------------------------------------------
program-15
-------------------
package Wednesday;

public class MethodOverloading 
{
int sum(int a,int b)
{
	return a+b;
}
int sum(int a,int b,int c)
{
	return a+b+c;
}
float sum(float a,float b)
{
	return a+b;
}
double sum(double a,double b)
{
	return a+b;
}
public static void main(String[] args) {
	MethodOverloading ob=new MethodOverloading();
	System.out.println("the sum is "+ob.sum(6, 7));
	System.out.println("the sum is "+ob.sum(6,7,8));
	System.out.println("the sum is "+ob.sum(6.5f, 7.3f));
	System.out.println("the sum is "+ob.sum(6.53, 7.32));
		}
}

------------------------------------------------------------------------------------------------------
Method Overriding:- runtime Polymerphism.(abstract class,Interface).we need two or more class.
------------------------------------------------------------------------------------------------------
program-16
---------------------
package Wednesday;
class Parent
{
void display()
{
	System.out.println("This is a parent class");
}
}
public class MethodOverriding extends Parent
{
	void display()
	{
		System.out.println("this is new display method");
	}
	public static void main(String[] args) 
	{
		MethodOverriding ob=new MethodOverriding();
		ob.display();
	}
}

-----------------------------------------------------------------
Here in the parent class we have the display().
In the child class we have display().We are creating object of the child class.
The child class display() is overriding on the parent class display().The parent class display() is hidden.
----------------------------------------------------------------------------
Abstract class
------------------------
It is a class which contain abstract method means method without body.
It can also contain method with body known as concret method.
we cannot create object of the abstract class.
we have to inherite it into a child class where we have to override the abstract methods.
Then we can create object for the child class.
We cannot have a method without body .we have to declare it as abstract or it should be inside the interface.
What is the use of abstract class.
It contains some abstract methods which has to be overriden inside the child class.
We can have a constructor in the abstract class.
*abstract windowing toolkit(AWT)

-------------------------------------------------------------------
program-17
------------------
package Wednesday;
abstract class Abstract1
{
Abstract1()
{
	System.out.println("this is a constractor");
}
abstract void display();
int sum(int a,int b)
{
	return a+b;
}
}
class AbstractDemo extends Abstract1
{
	@Override
	void display() 
	{
		System.out.println("This is display");
		}
	public static void main(String[] args) {
		AbstractDemo ob=new AbstractDemo();
		System.out.println("the sum is "+ob.sum(6, 3));
		ob.display();
	}
}
-----------------------------------------------------------------------------
--------------------------------------------------------------------------
Create a abstract class bank 
having abstract methods register(),apply for loan,credit card,dedit card.
create a child class customer .override all the methods and create object.
--------------------------------------------------------------------------------------------
Interface:-
It is similar to abstract class but it only contains abstract methods no concrete methods.we don't use the keyword abstract in this.
We cannot create object for an interface.
We have to implement the interface into a child class.
We have to override the abstract methods into a child class and create object for the child class.
By interface java performs the multiple Inheritance.
we can declare a variable inside a interface .this is by default static(we can access it without object )
and final(cann't be changed)
--------------------------------------------------------------------------------------------------
progarm-19
-----------------------
package Wednesday;
 interface Interface1
 {
void display1();
}
 interface Interface2 extends Interface1
 {
void display2();
}
 interface Interface3
 {
void display3();
}
 interface Interface4 
 {
void display4();
}
 class InterfaceDemo implements Interface2,Interface3,Interface4
 {
	@Override
	public void display1() {
				System.out.println("display1");	 }
	@Override
	public void display4() {
		System.out.println("display4");		}
	@Override
	public void display3() {
		System.out.println("display3");			}
	@Override
	public void display2() {
		System.out.println("display2");
			}
	 public static void main(String[] args) {
		 InterfaceDemo ob=new InterfaceDemo();
	ob.display1(); ob.display2(); ob.display3();  ob.display4();
	}
 }
 -------------------------------------------------------------------------------------------------------------------
 program-20
-------------------------
package Wednesday;
 interface Interface1
 {
	 int a=10;//this is by default static(we can access it without object and final(cann't be changed)
void display1();
}
 interface Interface2 extends Interface1
 {
void display2();
}
 interface Interface3
 {
void display3();
}
 interface Interface4 
 {
void display4();
}
 class InterfaceDemo implements Interface2,Interface3,Interface4
 {
	@Override
	public void display1() {
				System.out.println("display1");	 }
	@Override
	public void display4() {
		System.out.println("display4");		}
	@Override
	public void display3() {
		System.out.println("display3");			}
	@Override
	public void display2() {
		System.out.println("display2");
			}
	 public static void main(String[] args)
	 {
		 System.out.println("the value of a is "+a);
		 InterfaceDemo ob=new InterfaceDemo();
		 ob.display1(); ob.display2(); ob.display3();  ob.display4();
	}
 }
-----------------------------------------------------------------------------------------------------------

System.out.println()

System------class
out is an static object
println() ----method
-------------------------------------------------------------------------------
oops concept
----------------------
1)class --it is object factory or framework/blue print of an object.
It contains variables and methods .
2)Object ---it is a referance pointer.By this we can access variables and methods of a class.
3)Inheritance--It in we have parent and child concept.The child will access the variables and methods of the parent class.It is also known as re-usablity of existing code.
4)polymerphisim:-
  Method Overloading :- compile time Polymerphism.we need one class.
The method name is same but the return type and parameter has different data type.
example:-
int sum(int a,int b);
float sum(float a,float b);

Method Overriding:- runtime Polymerphism.(abstract class,Interface).we need two or more class.
5)encapsulation:- data protection/hiding.like a capsule protect the medicine by it's plastic coating.
Here data is protected/hidden by using private access specifier.One class data will not be visible to other class.

6)abstraction:- 
we switch on the fan it start rotating.
In this the complex part is hidden.The electricity is generated in a hydrolic/thermal power station.Then with transfers and cables it comes to our house. 
So in methods we write complex algorithim which is hidden and within the class we call the methods by using objects.
The complex part is hidden from the end users.The output is seen by the users.

---------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
 static :- we can declare a variable as static,method as static,we can have static block and we can have static class.
We can access it without creating an object.
We can access it with the help of the class name.
A single copy of the static variable,method,block or class is created in the JVM.
It is used for memory management.
If we declare a static block it execute before the main method.
---------------------------
progarm-21
---------------------------
package Wednesday;
public class StaticDemo 
{
static int rollno=10;
static String name="trupti";
static String address="orissa";
static void display()
{
	System.out.println(rollno+ " "+name+"  "+address);
}
static
{
	System.out.println("This is a static block");
}
public static void main(String[] args)
{
System.out.println("rollno is "+rollno);	
System.out.println("the name is "+StaticDemo.name);
System.out.println("the address is"+StaticDemo.address);
display();
StaticDemo.display();
}}
 ----------------------------------------------------------------------------------------------
 we cannot access a non-static variables inside a static method.
we can access static variables inside a non-static method.
program-22
----------------------
package Wednesday;
public class StaticDemo 
{
static int rollno=10;
static String name="trupti";
 static String address="orissa";
static void display()//we cannot access a non-static variable inside a static method.
{
	System.out.println(rollno+ " "+name+"  "+address);
}
static 
{
	System.out.println("This is a static block");
}
public static void main(String[] args)//we cannot access a non-static variable inside a static method.
{
System.out.println("rollno is "+rollno);	
System.out.println("the name is "+StaticDemo.name);
System.out.println("the address is"+StaticDemo.address);
display();
StaticDemo.display();
}}
--------------------------------------------------------
Once incremented the static variable value remain incremented.
 program-23
--------------------------

package Wednesday;
public class StaticDemo 
{
static int rollno=10;
static String name="trupti";
 static String address="orissa";
 static int i;
static void display()//we cannot access a non-static variable inside a static method.
{
	System.out.println(rollno+ " "+name+"  "+address);
}
static void counter()
{
	i++;
	System.out.println(i);
}
static 
{
	System.out.println("This is a static block");
}
public static void main(String[] args)//we cannot access a non-static variable inside a static method.
{
System.out.println("rollno is "+rollno);	
System.out.println("the name is "+StaticDemo.name);
System.out.println("the address is"+StaticDemo.address);
display();
StaticDemo.display();
counter();
counter();
counter();
counter();
}}
----------------------------------------------------------------------------------------------------
 final keyword
-------------------------
This is a done to protect the data.
We can declare the variable as final,method as final and class as final.
If we declare variable as final we have to assign it and it cannot be changed.
If we declare method as final we cannot override it.
If we declare a class as final we cannot inherite it.
--------------------------------------------------------------------------------------------------
program-24
-----------------------
package Wednesday;
public final class FinalDemo 
{
final int a=10;
final void display()
{
	System.out.println("this is final display");
}
public static void main(String[] args) {
	FinalDemo ob=new FinalDemo();
	ob.display();
	System.out.println("the value of a is"+ob.a);
}
}
------------------------------------------------------------------------------ 
 create an interface employee :- 
input details(empno,name,address);
display details();
-------------------------------------------------
create a child class to take input and display the details
--------------------------------------------------------------------------------------
static class:- It is used in the case of inner class.A inner class can be static.
syntax:-
class outer 
{
static int rollno=20;
static class inner
{
}
main
{
outer.inner obj=new outer.inner();
}}
---------------------------------------------------------------
program-25
------------------------
package Thrusday;

public class OuterClass 
{
static int rollno=10;//class variable,global variables can be accessed anywhere within the program
static String name="sandip";
static class inner
{
	void display()
	{
		System.out.println("The rollno is "+rollno);
		System.out.println("The name is "+name);
	}
}
public static void main(String[] args) 
{
OuterClass.inner obj=new OuterClass.inner();
obj.display();
}
}
------------------------------------------------------------------
exception handling
---------------------------------
package org.sandip;
import java.util.*;
public class ErrorExample 
{
public static void main(String[] args) 
{
	try
	{
Scanner ob=new Scanner(System.in);
System.out.println("Enter 2 nos");
int a=ob.nextInt();
int b=ob.nextInt();
int c=a/b;
System.out.println("The result is "+c);
	}
	catch(Exception ae)
	{
		System.out.println("the error is "+ae);
	}
System.out.println("The end of the program");
}
}
-----------------------------------------------------------------------
import java.util.*;
public class ErrorExample 
{
public static void main(String[] args) 
{
	try
	{
Scanner ob=new Scanner(System.in);
System.out.println("Enter 2 nos");
int a=ob.nextInt();
int b=ob.nextInt();
int c=a/b;
System.out.println("The result is "+c);
	}
	catch(ArithmeticException ae)
	{
		System.out.println("the error is "+ae);
	}
	catch(InputMismatchException ae)
	{
		System.out.println("the errorr is "+ae);
	}
	catch(Exception ae) //this can handle all types of error
	{
		System.out.println("the errorrr is "+ae);
	}
System.out.println("The end of the program");
}
}
----------------------------------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class ErrorExample 
{
public static void main(String[] args) 
{
	try
	{
Scanner ob=new Scanner(System.in);
System.out.println("Enter 2 nos");
int a=ob.nextInt();
int b=ob.nextInt();
int c=a/b;
System.out.println("The result is "+c);
	}

	finally
	{
	System.out.println("The end of the program");
	}
}
}
----------------------------------------------------------------------------------------------
* finally block is mainly used for connection closing,class closing.. etc.The finally block definetly exceute.
---------------------------------------------------------------------------------------------------------
import java.util.*;
public class ErrorExample 
{
public static void main(String[] args) throws Exception
{
	Scanner ob=new Scanner(System.in);
	System.out.println("enter your age to cast your vote");
	int age=ob.nextInt();
	if(age>=18)
		System.out.println("your are eligible to cash your vote");
	else
		throw new Exception("The age should be greater than or equal to 18 to caste your vote");
}
}

----------------------------------------------------------------------
Collection Framework
----------------------------------------
int a[]=new int[5]; ---------------array the size is fixed.
In case of Collection the size will be incrementing or decrement dyamically as we enter the data or remove the data.
---------------------------------------------------------------
It is a collection of Object.
It provides architecture to store,manupulate group of Objects.
We can do all operations such as searching,sorting,inserting,delete,manupulating .
1)Set 2)List 3)Map4)Queue are inteface.
----------------------------------------------------------------------------
Set is a Interface .It doesnot allow duplicate data.
It has classes :-
1)TreeSet :- It will display the data in the shorted order.
2)HashSet :-It will display the data in random order.
3)LinkedHashSet :- It will display the data in same order.
---------------------------------------------------------------------------
List :-It is an Interface.
It allows duplicate records.
We have classes 1)Stack 2)ArrayList 3)Linkedlist 4)Vector
stack :FILO .The last element will be index 0.
List display in the same order.
---------------------------------------------------------------------------
Example of Treeset
-------------------------------------------------------------------
It will display the data in the shorted order.
-------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class SetExample 
{
public static void main(String[] args) 
{
TreeSet<Integer> ts=new TreeSet<Integer>();
ts.add(20);
ts.add(30);
ts.add(50);
ts.add(40);
ts.add(50);
ts.add(20);
ts.add(40);
ts.add(70);
System.out.println(ts);
}
}
---------------------------------------------------------------I
HashSet:-
It will display the data in random order.
--------------------------------------------------------------
package org.sandip;
import java.util.*;
public class SetExample 
{
public static void main(String[] args) 
{
HashSet<Integer> ts=new HashSet<Integer>();
ts.add(20);
ts.add(30);
ts.add(50);
ts.add(40);
ts.add(50);
ts.add(20);
ts.add(40);
ts.add(70);
System.out.println(ts);
}
}
--------------------------------------------------------------------------------------
LinkedHashSet :- It will display the data in same order.
--------------------------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class SetExample 
{
public static void main(String[] args) 
{
LinkedHashSet<Integer> ts=new LinkedHashSet<Integer>();
ts.add(20);
ts.add(30);
ts.add(50);
ts.add(40);
ts.add(50);
ts.add(20);
ts.add(40);
ts.add(70);
System.out.println(ts);
}
}
-----------------------------------------------------------------------------------------
Linked list
----------------------------------------------------------------------------------------
It allows duplicate records.It will display in the same order.
package org.sandip;
import java.util.*;
public class SetExample 
{
public static void main(String[] args) 
{
LinkedList<Integer> ts=new LinkedList<Integer>();
ts.add(20);
ts.add(30);
ts.add(50);
ts.add(40);
ts.add(50);
ts.add(20);
ts.add(40);
ts.add(70);
System.out.println(ts);
}
}
---------------------------------------------------------------------------------------

example-1
------------------------
package org.sandip;
public class Student1 
{
int rollno;
String name,address;
public Student1(int rollno, String name, String address) 
{
	this.rollno = rollno;
	this.name = name;
	this.address = address;
}
@Override
public String toString() {
	return "Student1 [rollno=" + rollno + ", name=" + name + ", address=" + address + "]";
}
}
-----------------------------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class ListDemo 
{
public static void main(String[] args) 
{
Student1 st1=new Student1(101,"sandip","Bangalore");
Student1 st2=new Student1(102,"Kiran","Bangalore");
Student1 st3=new Student1(103,"sunil","Bangalore");
LinkedList<Student1> ls=new LinkedList<Student1>();
ls.add(st1);
ls.add(st2);
ls.add(st3);
System.out.println(ls);
for(Object obj:ls)
	System.out.println(obj);
}
}
---------------------------------------------------------------------------------------------------------
example-2
-------------------
package org.sandip;
import java.util.*;
public class TreeSetDemo 
{
public static void main(String[] args) {
	TreeSet<Integer> ts=new TreeSet<Integer>();
	System.out.println(ts.isEmpty());
	System.out.println(ts.size());
	ts.add(70);
	ts.add(50);
	ts.add(60);
	ts.add(40);
	ts.add(30);
	ts.add(20);
	ts.add(10);
	System.out.println(ts.isEmpty());
	System.out.println(ts.size());
	System.out.println(ts.contains(10));
	System.out.println(ts.contains(80));
	ts.remove(50);
	System.out.println(ts.size());
	ts.clear();
	System.out.println(ts);
	System.out.println(ts.size());
}
	}
----------------------------------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class TreeSetDemo 
{
public static void main(String[] args) {
	TreeSet<Integer> ts=new TreeSet<Integer>();
	ts.add(70);
	ts.add(50);
	ts.add(60);
	ts.add(40);
	ts.add(30);
	ts.add(20);
	ts.add(10);
	Iterator<Integer> itr=ts.iterator();
	while(itr.hasNext())
	{
		System.out.println(itr.next());
	}
	System.out.println("************************************");
	for(Object obj:ts)
	{
		System.out.println(obj);
	}
}
	}
-----------------------------------------------------------------------------------------------------------------------------
*Iterator is an interface .It contains 3 methods
1)hasNext()
2)next()
3)remove()
------------------------------
package org.sandip;
import java.util.*;
public class TreeSetDemo 
{
public static void main(String[] args) {
	TreeSet<Integer> ts=new TreeSet<Integer>();
	ts.add(70);
	ts.add(50);
	ts.add(60);
	ts.add(40);
	ts.add(30);
	ts.add(20);
	ts.add(10);
	Iterator<Integer> itr=ts.iterator();
	while(itr.hasNext())
	{
		System.out.println(itr.next());
		itr.remove();
	}
	System.out.println(ts);
	System.out.println("************************************");
	for(Object obj:ts)
	{
		System.out.println(obj);
	}
	System.out.println(ts);
}
	}
--------------------------------------------------------------------------------------------------------------------
package org.sandip;
import java.util.*;
public class TreeSetDemo 
{
public static void main(String[] args) {
	TreeSet<Integer> ts=new TreeSet<Integer>();
	ts.add(70);
	ts.add(50);
	ts.add(60);
	ts.add(40);
	ts.add(30);
	ts.add(20);
	ts.add(10);
	//ts.clear();		
	Iterator<Integer> itr=ts.iterator();
	while(itr.hasNext())
	{
		System.out.println(itr.next());
		//itr.remove();  
	}
	System.out.println(ts);
	System.out.println("************************************");
	
	for(Object obj:ts)
	{
		System.out.println(obj);
	}
	System.out.println(ts);
}
	}
-------------------------------------------------------------------------------------------------------------------------------





